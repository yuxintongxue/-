<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>完整CNN特征提取与分类动画演示（32→16详细版）</title>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --accent-color: #f1c40f;
            --success-color: #2ecc71;
            --danger-color: #e74c3c;
            --light-bg: #f5f7fa;
            --white: #ffffff;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--light-bg);
            color: #333;
            line-height: 1.6;
        }
        
        h1, h2, h3 {
            color: var(--secondary-color);
            margin-bottom: 15px;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }
        
        .header {
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .explanation {
            background-color: var(--white);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .demo-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
        }
        
        .grid-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
            background-color: var(--white);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        
        .grid {
            display: grid;
            gap: 2px;
            margin: 10px 0;
            border: 2px solid var(--secondary-color);
            background-color: #ecf0f1;
            padding: 5px;
            border-radius: 5px;
        }
        
        .grid-cell {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border-radius: 3px;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .input-channel1 .grid-cell {
            background-color: #ff6b6b;
            color: white;
        }
        
        .input-channel2 .grid-cell {
            background-color: #51cf66;
            color: white;
        }
        
        .input-channel3 .grid-cell {
            background-color: #339af0;
            color: white;
        }
        
        .kernel-channel1 .grid-cell {
            background-color: #ff8787;
            color: white;
        }
        
        .kernel-channel2 .grid-cell {
            background-color: #69db7c;
            color: white;
        }
        
        .kernel-channel3 .grid-cell {
            background-color: #4dabf7;
            color: white;
        }
        
        .feature-map .grid-cell {
            background-color: white;
            color: #333;
            border: 1px solid #ddd;
        }
        
        .feature-map-0 .grid-cell { background-color: #e3f2fd; }
        .feature-map-1 .grid-cell { background-color: #e8f5e9; }
        .feature-map-2 .grid-cell { background-color: #fff3e0; }
        .feature-map-3 .grid-cell { background-color: #fce4ec; }
        
        .pooled-map .grid-cell { background-color: #e1bee7; }
        .projected-map .grid-cell { background-color: #c8e6c9; }
        .final-vector .grid-cell { background-color: #bbdefb; }
        
        .highlight {
            background-color: var(--accent-color) !important;
            box-shadow: 0 0 8px rgba(241, 196, 15, 0.8);
            transform: scale(1.1);
        }
        
        .pool-region {
            border: 2px dashed var(--accent-color);
            background-color: rgba(241, 196, 15, 0.2);
        }
        
        .calculation {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 14px;
            border-left: 4px solid var(--primary-color);
        }
        
        .formula {
            text-align: center;
            font-size: 18px;
            margin: 20px 0;
            padding: 10px;
            background-color: #e8f4fd;
            border-radius: 5px;
            font-family: monospace;
        }
        
        .color-legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        
        .color-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .color-box {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }
        
        .red { background-color: #ff6b6b; }
        .green { background-color: #51cf66; }
        .blue { background-color: #339af0; }
        .light-red { background-color: #ff8787; }
        .light-green { background-color: #69db7c; }
        .light-blue { background-color: #4dabf7; }
        .feature-0 { background-color: #e3f2fd; }
        .feature-1 { background-color: #e8f5e9; }
        .feature-2 { background-color: #fff3e0; }
        .feature-3 { background-color: #fce4ec; }
        .pooled { background-color: #e1bee7; }
        .projected { background-color: #c8e6c9; }
        .final { background-color: #bbdefb; }
        
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 10px 20px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        button:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .step-indicator {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin: 15px 0;
            color: var(--secondary-color);
            padding: 15px;
            background-color: var(--white);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        
        .kernels-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
        }
        
        .kernel-set {
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            background-color: var(--white);
            transition: all 0.3s ease;
        }
        
        .kernel-set:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .feature-maps-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
        }
        
        .feature-map-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            background-color: var(--white);
            transition: all 0.3s ease;
        }
        
        .feature-map-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .architecture {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .arch-item {
            padding: 10px 15px;
            background-color: var(--white);
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .arch-item:hover {
            transform: scale(1.05);
        }
        
        .arrow {
            font-size: 20px;
            color: #7f8c8d;
        }
        
        .small-text {
            font-size: 12px;
            color: #7f8c8d;
        }
        
        .progress-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 5px;
            margin: 20px 0;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 10px;
            background-color: var(--primary-color);
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .footer {
            text-align: center;
            padding: 20px;
            margin-top: 40px;
            color: #7f8c8d;
            font-size: 14px;
            border-top: 1px solid #ddd;
        }
        
        @media (max-width: 768px) {
            .grid-cell {
                width: 25px;
                height: 25px;
                font-size: 10px;
            }
            
            .demo-area {
                gap: 15px;
            }
            
            .kernels-container, .feature-maps-container {
                gap: 10px;
            }
            
            .color-legend {
                gap: 10px;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            button {
                width: 100%;
                max-width: 300px;
            }
        }
        
        @media (max-width: 480px) {
            .grid-cell {
                width: 20px;
                height: 20px;
                font-size: 8px;
            }
            
            .architecture {
                flex-direction: column;
            }
            
            .arrow {
                transform: rotate(90deg);
            }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .pulse {
            animation: pulse 1s infinite;
        }
        
        .process-flow {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin: 30px 0;
        }
        
        .process-step {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background-color: var(--white);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .step-number {
            width: 30px;
            height: 30px;
            background-color: var(--primary-color);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .step-content {
            flex: 1;
        }
        
        .step-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .step-description {
            font-size: 14px;
            color: #7f8c8d;
        }
        
        .projection-kernels {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }
        
        .projection-kernel {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .projection-kernel-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 2px;
        }
        
        .projection-kernel-cell {
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 10px;
            transition: all 0.3s ease;
        }
        
        .projection-kernel-cell.highlight {
            background-color: var(--accent-color);
            box-shadow: 0 0 8px rgba(241, 196, 15, 0.8);
            transform: scale(1.1);
        }
        
        .final-vector-container {
            width: 100%;
            overflow-x: auto;
        }
        
        .final-vector {
            display: grid;
            grid-template-columns: repeat(32, 1fr);
            gap: 2px;
            min-width: 1040px; /* 32 * 30px + 31 * 2px */
        }
        
        .classification-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .class-scores {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .class-score {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            background-color: var(--white);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-width: 120px;
            transition: all 0.3s ease;
        }
        
        .class-score.highlight {
            background-color: var(--accent-color);
            transform: scale(1.05);
        }
        
        .class-label {
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .class-probability {
            font-size: 20px;
            font-weight: bold;
            color: var(--secondary-color);
        }
        
        .prediction-result {
            padding: 20px;
            background-color: var(--white);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin-top: 20px;
            transition: all 0.3s ease;
        }
        
        .prediction-result.highlight {
            background-color: var(--success-color);
            color: white;
            transform: scale(1.05);
        }
        
        .class-weights {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }
        
        .class-weight {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .class-weight-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
        }
        
        .class-weight-cell {
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 10px;
            transition: all 0.3s ease;
        }
        
        .class-weight-cell.highlight {
            background-color: var(--accent-color);
            box-shadow: 0 0 8px rgba(241, 196, 15, 0.8);
            transform: scale(1.1);
        }
        
        .hidden-layer {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }
        
        .hidden-layer-title {
            font-weight: bold;
            font-size: 14px;
        }
        
        .hidden-layer-values {
            display: flex;
            gap: 5px;
        }
        
        .hidden-layer-value {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #e8f4fd;
            border: 1px solid #b3d9ff;
            border-radius: 3px;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .hidden-layer-value.highlight {
            background-color: var(--accent-color);
            box-shadow: 0 0 8px rgba(241, 196, 15, 0.8);
            transform: scale(1.1);
        }
        
        .softmax-calculation {
            background-color: #f0f8ff;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 14px;
            border-left: 4px solid #4dabf7;
        }
        
        .softmax-step {
            margin: 10px 0;
        }
        
        .probability-bar-container {
            width: 100%;
            height: 30px;
            background-color: #e0e0e0;
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .probability-bar {
            height: 100%;
            background-color: var(--primary-color);
            width: 0%;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        
        .fc1-weights-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .fc1-neuron-weights {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .fc1-neuron-label {
            min-width: 100px;
            font-weight: bold;
        }
        
        .fc1-weights-grid {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 2px;
        }
        
        .fc1-weight-cell {
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 10px;
            transition: all 0.3s ease;
        }
        
        .fc1-weight-cell.highlight {
            background-color: var(--accent-color);
            box-shadow: 0 0 8px rgba(241, 196, 15, 0.8);
            transform: scale(1.1);
        }
        
        .matrix-visualization {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin: 20px 0;
        }
        
        .matrix-row {
            display: flex;
            gap: 5px;
        }
        
        .matrix-cell {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .matrix-cell.highlight {
            background-color: var(--accent-color);
            box-shadow: 0 0 8px rgba(241, 196, 15, 0.8);
            transform: scale(1.1);
        }
        
        .matrix-label {
            font-weight: bold;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>完整CNN特征提取与分类动画演示（32→16详细版）</h1>
            <p>从原始图像到最终分类结果的完整流程，重点展示32维到16维的转换</p>
        </div>
        
        <div class="explanation">
            <h2>完整CNN特征提取与分类流程</h2>
            <p>在真实的卷积神经网络中，特征提取后通常跟随多层感知机进行分类：</p>
            
            <div class="architecture">
                <div class="arch-item">
                    <div>原始输入</div>
                    <div class="small-text">[3, 5, 5]</div>
                </div>
                <div class="arrow">→</div>
                <div class="arch-item">
                    <div>ConvNeXt-Tiny Backbone</div>
                    <div class="small-text">特征提取</div>
                </div>
                <div class="arrow">→</div>
                <div class="arch-item">
                    <div>特征图</div>
                    <div class="small-text">[4, 3, 3]</div>
                </div>
                <div class="arrow">→</div>
                <div class="arch-item">
                    <div>AdaptiveAvgPool2d</div>
                    <div class="small-text">2×2池化（降维）</div>
                </div>
                <div class="arrow">→</div>
                <div class="arch-item">
                    <div>池化后</div>
                    <div class="small-text">[4, 2, 2]</div>
                </div>
                <div class="arrow">→</div>
                <div class="arch-item">
                    <div>1×1卷积投影</div>
                    <div class="small-text">4→8</div>
                </div>
                <div class="arrow">→</div>
                <div class="arch-item">
                    <div>投影后</div>
                    <div class="small-text">[8, 2, 2]</div>
                </div>
                <div class="arrow">→</div>
                <div class="arch-item">
                    <div>重塑</div>
                    <div class="small-text">展平</div>
                </div>
                <div class="arrow">→</div>
                <div class="arch-item">
                    <div>特征向量</div>
                    <div class="small-text">[32]</div>
                </div>
                <div class="arrow">→</div>
                <div class="arch-item">
                    <div>全连接层1</div>
                    <div class="small-text">32→16</div>
                </div>
                <div class="arrow">→</div>
                <div class="arch-item">
                    <div>隐藏层</div>
                    <div class="small-text">[16]</div>
                </div>
                <div class="arrow">→</div>
                <div class="arch-item">
                    <div>全连接层2</div>
                    <div class="small-text">16→4</div>
                </div>
                <div class="arrow">→</div>
                <div class="arch-item">
                    <div>类别分数</div>
                    <div class="small-text">[4]</div>
                </div>
                <div class="arrow">→</div>
                <div class="arch-item">
                    <div>Softmax</div>
                    <div class="small-text">概率分布</div>
                </div>
                <div class="arrow">→</div>
                <div class="arch-item">
                    <div>最终预测</div>
                    <div class="small-text">类别</div>
                </div>
            </div>
            
            <div class="formula">
                完整流程: 输入 → 卷积 → 特征图 → 池化 → 投影 → 重塑 → 全连接层1 → 隐藏层 → 全连接层2 → Softmax → 预测
            </div>
        </div>
        
        <div class="color-legend">
            <div class="color-item">
                <div class="color-box red"></div>
                <span>输入通道1</span>
            </div>
            <div class="color-item">
                <div class="color-box green"></div>
                <span>输入通道2</span>
            </div>
            <div class="color-item">
                <div class="color-box blue"></div>
                <span>输入通道3</span>
            </div>
            <div class="color-item">
                <div class="color-box feature-0"></div>
                <span>特征图</span>
            </div>
            <div class="color-item">
                <div class="color-box pooled"></div>
                <span>池化后</span>
            </div>
            <div class="color-item">
                <div class="color-box projected"></div>
                <span>投影后</span>
            </div>
            <div class="color-item">
                <div class="color-box final"></div>
                <span>最终输出</span>
            </div>
        </div>
        
        <div class="step-indicator" id="stepIndicator">
            <div>准备演示完整CNN特征提取与分类流程...</div>
            <div class="progress-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
        </div>
        
        <div class="process-flow">
            <div class="process-step">
                <div class="step-number">1</div>
                <div class="step-content">
                    <div class="step-title">原始输入: [3, 5, 5]</div>
                    <div class="step-description">3通道的5×5输入图像</div>
                </div>
            </div>
            
            <div class="demo-area">
                <div class="grid-container">
                    <h3>输入图像 (3×5×5)</h3>
                    <div>通道 1</div>
                    <div class="grid input-channel1" id="input1" style="grid-template-columns: repeat(5, 1fr);"></div>
                    <div>通道 2</div>
                    <div class="grid input-channel2" id="input2" style="grid-template-columns: repeat(5, 1fr);"></div>
                    <div>通道 3</div>
                    <div class="grid input-channel3" id="input3" style="grid-template-columns: repeat(5, 1fr);"></div>
                </div>
                
                <div class="grid-container">
                    <h3>4个卷积核 (每个3×3×3)</h3>
                    <div class="kernels-container" id="kernelsContainer"></div>
                </div>
            </div>
            
            <div class="process-step">
                <div class="step-number">2</div>
                <div class="step-content">
                    <div class="step-title">ConvNeXt-Tiny Backbone → 特征图: [4, 3, 3]</div>
                    <div class="step-description">通过卷积层提取特征（滑动计算）</div>
                </div>
            </div>
            
            <div class="grid-container">
                <h3>4个特征图 (每个3×3)</h3>
                <div class="feature-maps-container" id="featureMapsContainer"></div>
            </div>
            
            <div class="process-step">
                <div class="step-number">3</div>
                <div class="step-content">
                    <div class="step-title">AdaptiveAvgPool2d(2×2) → 池化后: [4, 2, 2]</div>
                    <div class="step-description">自适应平均池化（区域聚合，非滑动）</div>
                </div>
            </div>
            
            <div class="grid-container">
                <h3>池化后的特征图 (4×2×2)</h3>
                <div class="feature-maps-container" id="pooledMapsContainer"></div>
            </div>
            
            <div class="process-step">
                <div class="step-number">4</div>
                <div class="step-content">
                    <div class="step-title">1×1卷积投影 (4→8) → 投影后: [8, 2, 2]</div>
                    <div class="step-description">1×1卷积（无空间滑动，仅通道加权）</div>
                </div>
            </div>
            
            <div class="demo-area">
                <div class="grid-container">
                    <h3>投影后的特征图 (8×2×2)</h3>
                    <div class="feature-maps-container" id="projectedMapsContainer"></div>
                </div>
                
                <div class="grid-container">
                    <h3>投影卷积核 (8个不同的1×1卷积核)</h3>
                    <div class="projection-kernels" id="projectionKernelsContainer"></div>
                </div>
            </div>
            
            <div class="process-step">
                <div class="step-number">5</div>
                <div class="step-content">
                    <div class="step-title">重塑 → 特征向量: [32]</div>
                    <div class="step-description">将8×2×2特征图展平为32维向量</div>
                </div>
            </div>
            
            <div class="grid-container">
                <h3>特征向量 (32维)</h3>
                <div class="final-vector-container">
                    <div class="grid final-vector" id="finalVector"></div>
                </div>
            </div>
            
            <div class="process-step">
                <div class="step-number">6</div>
                <div class="step-content">
                    <div class="step-title">全连接层1 (32→16) - 详细转换过程</div>
                    <div class="step-description">通过16个神经元的线性变换将32维特征向量转换为16维隐藏层</div>
                </div>
            </div>
            
            <div class="demo-area">
                <div class="grid-container">
                    <h3>全连接层1权重矩阵 (16×32)</h3>
                    <div class="matrix-visualization">
                        <div class="matrix-label">16个神经元 × 32个权重</div>
                        <div id="fc1WeightsMatrix"></div>
                    </div>
                </div>
                
                <div class="grid-container">
                    <h3>32→16转换过程</h3>
                    <div class="matrix-visualization">
                        <div class="matrix-label">当前计算：神经元 <span id="currentNeuron">0</span>，权重 <span id="currentWeight">0</span></div>
                        <div class="hidden-layer">
                            <div class="hidden-layer-title">特征向量 (32维)</div>
                            <div class="final-vector-container">
                                <div class="grid final-vector" id="featureVectorForFC1"></div>
                            </div>
                        </div>
                        <div class="hidden-layer">
                            <div class="hidden-layer-title">隐藏层 (16维)</div>
                            <div class="hidden-layer-values" id="hiddenLayer1"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="process-step">
                <div class="step-number">7</div>
                <div class="step-content">
                    <div class="step-title">全连接层2 (16→4) → Softmax → 最终预测</div>
                    <div class="step-description">将16维隐藏层映射到4个类别并计算概率分布</div>
                </div>
            </div>
            
            <div class="demo-area">
                <div class="grid-container">
                    <h3>分类结果</h3>
                    <div class="classification-container">
                        <div class="class-scores" id="classProbabilitiesContainer"></div>
                        <div class="prediction-result" id="predictionResult">等待分类...</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="calculation" id="calculation">
            点击"开始演示"查看详细计算过程...
        </div>
        
        <div class="controls">
            <button id="startBtn">开始演示</button>
            <button id="resetBtn">重置</button>
            <button id="nextBtn">下一步</button>
        </div>
        
        <div class="footer">
            <p>完整CNN特征提取与分类演示（32→16详细版） | 使用HTML、CSS和JavaScript构建</p>
        </div>
    </div>

    <script>
        // 1. 输入数据 (3通道，5x5)
        const inputData = [
            [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ],
            [ [5, 4, 3, 2, 1], [10, 9, 8, 7, 6], [15, 14, 13, 12, 11], [20, 19, 18, 17, 16], [25, 24, 23, 22, 21] ],
            [ [2, 4, 6, 8, 10], [3, 6, 9, 12, 15], [4, 8, 12, 16, 20], [5, 10, 15, 20, 25], [6, 12, 18, 24, 30] ]
        ];
        
        // 2. 4个卷积核（3×3×3）
        const kernelsData = [
            [ // 卷积核1 - 边缘检测 (Sobel X)
                [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]],
                [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]],
                [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]
            ],
            [ // 卷积核2 - 边缘检测 (Sobel Y)
                [[-1, -2, -1], [0, 0, 0], [1, 2, 1]],
                [[-1, -2, -1], [0, 0, 0], [1, 2, 1]],
                [[-1, -2, -1], [0, 0, 0], [1, 2, 1]]
            ],
            [ // 卷积核3 - 锐化
                [[0, -1, 0], [-1, 5, -1], [0, -1, 0]],
                [[0, -1, 0], [-1, 5, -1], [0, -1, 0]],
                [[0, -1, 0], [-1, 5, -1], [0, -1, 0]]
            ],
            [ // 卷积核4 - 模糊
                [[0.0625, 0.125, 0.0625], [0.125, 0.25, 0.125], [0.0625, 0.125, 0.0625]],
                [[0.0625, 0.125, 0.0625], [0.125, 0.25, 0.125], [0.0625, 0.125, 0.0625]],
                [[0.0625, 0.125, 0.0625], [0.125, 0.25, 0.125], [0.0625, 0.125, 0.0625]]
            ]
        ];
        
        // 3. 投影卷积核（8个不同的1×1卷积核，每个有4个权重）
        const projectionKernels = [
            [0.8, 0.2, -0.4, 0.6],  // 投影核1
            [0.3, 0.9, 0.1, -0.2],  // 投影核2
            [-0.5, 0.7, 0.2, 0.4],  // 投影核3
            [0.1, -0.3, 0.8, 0.5],  // 投影核4
            [0.6, 0.4, -0.1, 0.9],  // 投影核5
            [-0.2, 0.8, 0.3, 0.7],  // 投影核6
            [0.7, 0.1, 0.5, -0.3],  // 投影核7
            [0.4, -0.5, 0.9, 0.2]   // 投影核8
        ];
        
        // 4. 分类器参数 - 两层全连接网络
        const HIDDEN_LAYER_SIZE = 16;
        const NUM_CLASSES = 4;
        
        // 第一层权重 (32→16)
        const fc1Weights = Array(HIDDEN_LAYER_SIZE).fill().map(() => 
            Array(32).fill().map(() => (Math.random() * 2 - 1) * 0.1)
        );
        const fc1Biases = Array(HIDDEN_LAYER_SIZE).fill().map(() => (Math.random() * 2 - 1) * 0.1);
        
        // 第二层权重 (16→4)
        const fc2Weights = Array(NUM_CLASSES).fill().map(() => 
            Array(HIDDEN_LAYER_SIZE).fill().map(() => (Math.random() * 2 - 1) * 0.1)
        );
        const fc2Biases = Array(NUM_CLASSES).fill().map(() => (Math.random() * 2 - 1) * 0.1);
        
        const biases = [0.1, 0.2, 0.3, 0.4];
        const numKernels = 4;          // 卷积核数量
        const poolSize = 2;            // 池化后尺寸（2×2）
        const VISUAL_PROJ_CHANNELS = 8;// 投影通道数
        const POOL_REGIONS = [         // 池化区域定义（3×3→2×2的4个区域）
            [[0,0], [0,1], [1,0], [1,1]], // 区域1：对应池化(0,0)
            [[0,2], [1,2]],               // 区域2：对应池化(0,1)
            [[2,0], [2,1]],               // 区域3：对应池化(1,0)
            [[2,2]]                       // 区域4：对应池化(1,1)
        ];
        
        // 5. 关键变量初始化
        let currentStep = 0;
        let currentStage = 0; // 0:卷积, 1:池化, 2:投影, 3:重塑, 4:全连接1, 5:全连接2, 6:Softmax, 7:结束
        // 各阶段步骤计数器
        let convKernel = 0, convRow = 0, convCol = 0;  // 卷积阶段
        let poolKernel = 0, poolRegionIdx = 0;         // 池化阶段（按区域迭代，非滑动）
        let projChan = 0, projRow = 0, projCol = 0;    // 投影阶段
        let reshapeIdx = 0;                            // 重塑阶段
        let fc1Neuron = 0, fc1WeightIdx = 0;           // 全连接层1阶段
        let fc2Neuron = 0, fc2WeightIdx = 0;           // 全连接层2阶段
        let softmaxStep = 0;                           // Softmax阶段
        
        // 数据存储
        let featureMaps = Array(numKernels).fill().map(() => Array(3).fill().map(() => Array(3).fill(0)));
        let pooledMaps = Array(numKernels).fill().map(() => Array(poolSize).fill().map(() => Array(poolSize).fill(0)));
        let projectedMaps = Array(VISUAL_PROJ_CHANNELS).fill().map(() => Array(poolSize).fill().map(() => Array(poolSize).fill(0)));
        let finalVector = Array(VISUAL_PROJ_CHANNELS * poolSize * poolSize).fill(0);
        let hiddenLayer1 = Array(HIDDEN_LAYER_SIZE).fill(0);
        let classScores = Array(NUM_CLASSES).fill(0);
        let classProbabilities = Array(NUM_CLASSES).fill(0);
        
        // 总步骤数
        const TOTAL_STEPS = 
            numKernels * 3 * 3 +          // 卷积：4核×3×3=36步
            numKernels * POOL_REGIONS.length + // 池化：4核×4区域=16步
            VISUAL_PROJ_CHANNELS * 2 * 2 + // 投影：8通道×2×2=32步
            32 +                          // 重塑：显示32个元素=32步
            HIDDEN_LAYER_SIZE * 32 +      // 全连接层1：16神经元×32权重=512步
            NUM_CLASSES * HIDDEN_LAYER_SIZE + // 全连接层2：4类别×16权重=64步
            10;                           // Softmax：10步
        let isAnimating = false;
        let animationInterval;

        // 6. 工具函数：更新进度条
        function updateProgressBar() {
            const progress = Math.min(100, (currentStep / TOTAL_STEPS) * 100);
            document.getElementById('progressBar').style.width = `${progress}%`;
        }

        // 7. 初始化网格（页面加载时执行）
        function initializeGrids() {
            // 输入图像（3通道）
            for (let c = 0; c < 3; c++) {
                const grid = document.getElementById(`input${c+1}`);
                grid.innerHTML = '';
                for (let i = 0; i < 5; i++) {
                    for (let j = 0; j < 5; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.textContent = inputData[c][i][j];
                        cell.id = `input-${c}-${i}-${j}`;
                        grid.appendChild(cell);
                    }
                }
            }

            // 卷积核（4个，每个3通道）
            const kernelsContainer = document.getElementById('kernelsContainer');
            kernelsContainer.innerHTML = '';
            for (let k = 0; k < numKernels; k++) {
                const kernelSet = document.createElement('div');
                kernelSet.className = 'kernel-set';
                kernelSet.innerHTML = `<h4>卷积核 ${k+1}</h4>`;
                for (let c = 0; c < 3; c++) {
                    kernelSet.innerHTML += `<div>通道 ${c+1}</div>`;
                    const grid = document.createElement('div');
                    grid.className = `grid kernel-channel${c+1}`;
                    grid.style.gridTemplateColumns = 'repeat(3, 1fr)';
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            grid.innerHTML += `<div class="grid-cell" id="kernel-${k}-${c}-${i}-${j}">${kernelsData[k][c][i][j]}</div>`;
                        }
                    }
                    kernelSet.appendChild(grid);
                }
                kernelsContainer.appendChild(kernelSet);
            }

            // 特征图（4个3×3）
            const featureMapsContainer = document.getElementById('featureMapsContainer');
            featureMapsContainer.innerHTML = '';
            for (let k = 0; k < numKernels; k++) {
                featureMapsContainer.innerHTML += `
                    <div class="feature-map-item">
                        <h4>特征图 ${k+1}</h4>
                        <div class="grid feature-map feature-map-${k}" id="feature-map-${k}" style="grid-template-columns: repeat(3, 1fr);">
                            ${Array(9).fill().map((_, idx) => `<div class="grid-cell" id="feature-${k}-${Math.floor(idx/3)}-${idx%3}">0</div>`).join('')}
                        </div>
                    </div>
                `;
            }

            // 池化图（4个2×2）
            const pooledMapsContainer = document.getElementById('pooledMapsContainer');
            pooledMapsContainer.innerHTML = '';
            for (let k = 0; k < numKernels; k++) {
                pooledMapsContainer.innerHTML += `
                    <div class="feature-map-item">
                        <h4>池化特征图 ${k+1}</h4>
                        <div class="grid pooled-map" id="pooled-${k}" style="grid-template-columns: repeat(2, 1fr);">
                            ${Array(4).fill().map((_, idx) => `<div class="grid-cell" id="pooled-${k}-${Math.floor(idx/2)}-${idx%2}">0</div>`).join('')}
                        </div>
                    </div>
                `;
            }

            // 投影图（显示全部8个，水平排列）
            const projectedMapsContainer = document.getElementById('projectedMapsContainer');
            projectedMapsContainer.innerHTML = '';
            for (let k = 0; k < VISUAL_PROJ_CHANNELS; k++) {
                projectedMapsContainer.innerHTML += `
                    <div class="feature-map-item">
                        <h4>投影特征图 ${k+1}</h4>
                        <div class="grid projected-map" id="projected-${k}" style="grid-template-columns: repeat(2, 1fr);">
                            ${Array(4).fill().map((_, idx) => `<div class="grid-cell" id="projected-${k}-${Math.floor(idx/2)}-${idx%2}">0</div>`).join('')}
                        </div>
                    </div>
                `;
            }
            
            // 投影卷积核（显示8个不同的1×1卷积核）
            const projectionKernelsContainer = document.getElementById('projectionKernelsContainer');
            projectionKernelsContainer.innerHTML = '';
            for (let k = 0; k < VISUAL_PROJ_CHANNELS; k++) {
                const kernelDiv = document.createElement('div');
                kernelDiv.className = 'projection-kernel';
                kernelDiv.innerHTML = `
                    <div>投影核 ${k+1}:</div>
                    <div class="projection-kernel-grid" id="projection-kernel-${k}">
                        ${projectionKernels[k].map((weight, idx) => 
                            `<div class="projection-kernel-cell" id="projection-kernel-${k}-${idx}">${weight.toFixed(1)}</div>`
                        ).join('')}
                    </div>
                `;
                projectionKernelsContainer.appendChild(kernelDiv);
            }

            // 最终向量（显示全部32个，水平排列）
            const finalVectorGrid = document.getElementById('finalVector');
            finalVectorGrid.innerHTML = Array(32).fill().map((_, idx) => `<div class="grid-cell" id="vector-${idx}">0</div>`).join('');
            
            // 特征向量（用于全连接层1计算）
            const featureVectorForFC1 = document.getElementById('featureVectorForFC1');
            featureVectorForFC1.innerHTML = Array(32).fill().map((_, idx) => `<div class="grid-cell" id="fc1-vector-${idx}">0</div>`).join('');
            
            // 隐藏层1（16个神经元）
            const hiddenLayer1Container = document.getElementById('hiddenLayer1');
            hiddenLayer1Container.innerHTML = Array(HIDDEN_LAYER_SIZE).fill().map((_, idx) => 
                `<div class="hidden-layer-value" id="hidden1-${idx}">0</div>`
            ).join('');
            
            // 全连接层1权重矩阵可视化
            const fc1WeightsMatrix = document.getElementById('fc1WeightsMatrix');
            fc1WeightsMatrix.innerHTML = '';
            for (let i = 0; i < HIDDEN_LAYER_SIZE; i++) {
                const row = document.createElement('div');
                row.className = 'matrix-row';
                row.id = `fc1-weight-row-${i}`;
                for (let j = 0; j < 32; j++) {
                    row.innerHTML += `<div class="matrix-cell" id="fc1-weight-${i}-${j}">${fc1Weights[i][j].toFixed(2)}</div>`;
                }
                fc1WeightsMatrix.appendChild(row);
            }
            
            // 类别概率（4个类别）
            const classProbabilitiesContainer = document.getElementById('classProbabilitiesContainer');
            classProbabilitiesContainer.innerHTML = Array(NUM_CLASSES).fill().map((_, idx) => 
                `<div class="class-score" id="class-prob-${idx}">
                    <div class="class-label">类别 ${idx}</div>
                    <div class="class-probability">0.00</div>
                    <div class="probability-bar-container">
                        <div class="probability-bar" id="prob-bar-${idx}" style="width: 0%">0%</div>
                    </div>
                </div>`
            ).join('');
            
            updateProgressBar();
        }

        // 8. 清除所有高亮
        function clearAllHighlights() {
            document.querySelectorAll('.grid-cell').forEach(cell => cell.classList.remove('highlight'));
            document.querySelectorAll('.projection-kernel-cell').forEach(cell => cell.classList.remove('highlight'));
            document.querySelectorAll('.hidden-layer-value').forEach(cell => cell.classList.remove('highlight'));
            document.querySelectorAll('.matrix-cell').forEach(cell => cell.classList.remove('highlight'));
            document.querySelectorAll('.class-score').forEach(cell => cell.classList.remove('highlight'));
            document.getElementById('predictionResult').classList.remove('highlight');
        }

        // 9. 阶段1：卷积（滑动计算）
        function performConvolution() {
            clearAllHighlights();
            
            // 计算当前卷积位置的结果
            let sum = 0;
            let calcText = `卷积核 ${convKernel+1}，位置 (${convRow}, ${convCol})：<br>`;
            for (let c = 0; c < 3; c++) {
                calcText += `<br>通道 ${c+1}：`;
                let chanSum = 0;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        const inputVal = inputData[c][convRow+i][convCol+j];
                        const kernelVal = kernelsData[convKernel][c][i][j];
                        const product = inputVal * kernelVal;
                        chanSum += product;
                        calcText += `${inputVal}×${kernelVal} ${j<2 ? '+' : ''}`;
                        // 高亮当前输入和卷积核元素
                        document.getElementById(`input-${c}-${convRow+i}-${convCol+j}`).classList.add('highlight');
                        document.getElementById(`kernel-${convKernel}-${c}-${i}-${j}`).classList.add('highlight');
                    }
                }
                calcText += ` = ${chanSum.toFixed(2)}`;
                sum += chanSum;
            }
            // 加偏置+ReLU
            sum += biases[convKernel];
            const reluVal = Math.max(0, sum);
            calcText += `<br><br>总和：${sum.toFixed(2)} + 偏置(${biases[convKernel]}) = ${sum.toFixed(2)}<br>ReLU激活：max(0, ${sum.toFixed(2)}) = ${reluVal.toFixed(2)}`;
            
            // 更新特征图
            featureMaps[convKernel][convRow][convCol] = reluVal;
            const featureCell = document.getElementById(`feature-${convKernel}-${convRow}-${convCol}`);
            featureCell.textContent = reluVal.toFixed(2);
            featureCell.classList.add('highlight');
            
            // 更新UI
            document.getElementById('calculation').innerHTML = calcText;
            document.getElementById('stepIndicator').innerHTML = `
                <div>卷积阶段：计算卷积核 ${convKernel+1} 的特征图位置 (${convRow}, ${convCol})</div>
                <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
            `;
            
            // 步长更新
            currentStep++;
            updateProgressBar();
            convCol++;
            if (convCol >= 3) {
                convCol = 0;
                convRow++;
                if (convRow >= 3) {
                    convRow = 0;
                    convKernel++;
                    // 所有卷积核计算完成，进入池化阶段
                    if (convKernel >= numKernels) {
                        currentStage = 1;
                        poolKernel = 0;
                        poolRegionIdx = 0;
                        document.getElementById('stepIndicator').innerHTML = `
                            <div>卷积完成！进入池化阶段（区域聚合，非滑动）</div>
                            <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
                        `;
                    }
                }
            }
        }

        // 10. 阶段2：池化（区域聚合逻辑，非滑动）
        function performPooling() {
            clearAllHighlights();
            
            const kernel = poolKernel;
            const region = POOL_REGIONS[poolRegionIdx]; // 当前池化区域
            const [poolRow, poolCol] = [Math.floor(poolRegionIdx/2), poolRegionIdx%2]; // 池化结果位置
            
            // 计算区域平均值
            let sum = 0;
            let regionVals = [];
            for (const [r, c] of region) {
                const val = featureMaps[kernel][r][c];
                sum += val;
                regionVals.push(val.toFixed(2));
                // 高亮当前池化区域
                document.getElementById(`feature-${kernel}-${r}-${c}`).classList.add('highlight');
            }
            const avg = sum / region.length;
            pooledMaps[kernel][poolRow][poolCol] = avg;
            
            // 更新池化图
            const pooledCell = document.getElementById(`pooled-${kernel}-${poolRow}-${poolCol}`);
            pooledCell.textContent = avg.toFixed(2);
            pooledCell.classList.add('highlight');
            
            // 更新UI
            document.getElementById('calculation').innerHTML = `
                池化阶段：特征图 ${kernel+1}，区域 ${poolRegionIdx+1}<br>
                池化区域（3×3特征图中的位置）：${region.map(([r,c]) => `(${r},${c})`).join(', ')}<br>
                区域值：${regionVals.join(', ')}<br>
                平均值：${sum.toFixed(2)} / ${region.length} = ${avg.toFixed(2)}
            `;
            document.getElementById('stepIndicator').innerHTML = `
                <div>池化阶段：处理特征图 ${kernel+1} 的第 ${poolRegionIdx+1} 个区域</div>
                <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
            `;
            
            // 步长更新
            currentStep++;
            updateProgressBar();
            poolRegionIdx++;
            if (poolRegionIdx >= POOL_REGIONS.length) {
                poolRegionIdx = 0;
                poolKernel++;
                // 所有特征图池化完成，进入投影阶段
                if (poolKernel >= numKernels) {
                    currentStage = 2;
                    projChan = 0;
                    projRow = 0;
                    projCol = 0;
                    document.getElementById('stepIndicator').innerHTML = `
                        <div>池化完成！进入投影阶段（1×1卷积，无空间滑动）</div>
                        <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
                    `;
                }
            }
        }

        // 11. 阶段3：投影（1×1卷积）
        function performProjection() {
            clearAllHighlights();
            
            // 1×1卷积：同一空间位置（projRow, projCol）的所有输入通道加权求和
            let sum = 0;
            let weights = projectionKernels[projChan];
            let calcText = `投影阶段：通道 ${projChan+1}，位置 (${projRow}, ${projCol})<br>`;
            calcText += `1×1卷积（无空间滑动，仅通道加权）：<br>`;
            
            for (let c = 0; c < numKernels; c++) {
                const weight = weights[c];
                const val = pooledMaps[c][projRow][projCol];
                sum += val * weight;
                // 高亮当前输入通道的对应位置
                document.getElementById(`pooled-${c}-${projRow}-${projCol}`).classList.add('highlight');
                // 高亮当前使用的投影核权重
                document.getElementById(`projection-kernel-${projChan}-${c}`).classList.add('highlight');
            }
            
            // ReLU激活
            const reluVal = Math.max(0, sum);
            projectedMaps[projChan][projRow][projCol] = reluVal;
            
            // 更新投影图
            const projCell = document.getElementById(`projected-${projChan}-${projRow}-${projCol}`);
            projCell.textContent = reluVal.toFixed(2);
            projCell.classList.add('highlight');
            
            // 更新UI
            calcText += `输入通道权重：[${weights.map(w => w.toFixed(1)).join(', ')}]<br>`;
            calcText += `加权和：${sum.toFixed(2)}<br>`;
            calcText += `ReLU激活：max(0, ${sum.toFixed(2)}) = ${reluVal.toFixed(2)}`;
            document.getElementById('calculation').innerHTML = calcText;
            document.getElementById('stepIndicator').innerHTML = `
                <div>投影阶段：处理第 ${projChan+1}/${VISUAL_PROJ_CHANNELS} 个通道的 (${projRow}, ${projCol}) 位置</div>
                <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
            `;
            
            // 步长更新
            currentStep++;
            updateProgressBar();
            projCol++;
            if (projCol >= poolSize) {
                projCol = 0;
                projRow++;
                if (projRow >= poolSize) {
                    projRow = 0;
                    projChan++;
                    // 所有通道投影完成，进入重塑阶段
                    if (projChan >= VISUAL_PROJ_CHANNELS) {
                        currentStage = 3;
                        reshapeIdx = 0;
                        document.getElementById('stepIndicator').innerHTML = `
                            <div>投影完成！进入重塑阶段（展平特征图）</div>
                            <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
                        `;
                    }
                }
            }
        }

        // 12. 阶段4：重塑（展平，按顺序高亮并填入向量）
        function performReshape() {
            clearAllHighlights();
            
            // 展平逻辑：通道→行→列
            const chan = Math.floor(reshapeIdx / (poolSize * poolSize));
            const row = Math.floor((reshapeIdx % (poolSize * poolSize)) / poolSize);
            const col = reshapeIdx % poolSize;
            const val = projectedMaps[chan][row][col];
            finalVector[reshapeIdx] = val;
            
            // 高亮投影特征图中的当前元素
            const projCell = document.getElementById(`projected-${chan}-${row}-${col}`);
            projCell.classList.add('highlight');
            
            // 更新向量显示（全部32个）
            const vectorCell = document.getElementById(`vector-${reshapeIdx}`);
            vectorCell.textContent = val.toFixed(2);
            vectorCell.classList.add('highlight');
            
            // 更新用于全连接层1的特征向量
            const fc1VectorCell = document.getElementById(`fc1-vector-${reshapeIdx}`);
            fc1VectorCell.textContent = val.toFixed(2);
            
            // 更新UI，明确显示来源路径
            document.getElementById('calculation').innerHTML = `
                重塑阶段：将 ${VISUAL_PROJ_CHANNELS}×${poolSize}×${poolSize} 特征图展平为 ${VISUAL_PROJ_CHANNELS*poolSize*poolSize} 维向量<br>
                当前映射：通道 ${chan+1} → 行 ${row} → 列 ${col} → 向量索引 ${reshapeIdx}<br>
                数值：${val.toFixed(2)}
            `;
            document.getElementById('stepIndicator').innerHTML = `
                <div>重塑阶段：处理第 ${reshapeIdx+1}/${VISUAL_PROJ_CHANNELS*poolSize*poolSize} 个元素</div>
                <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
            `;
            
            // 步长更新
            currentStep++;
            updateProgressBar();
            reshapeIdx++;
            // 所有元素展平完成，进入全连接层1阶段
            if (reshapeIdx >= VISUAL_PROJ_CHANNELS * poolSize * poolSize) {
                currentStage = 4;
                fc1Neuron = 0;
                fc1WeightIdx = 0;
                document.getElementById('stepIndicator').innerHTML = `
                    <div>重塑完成！进入全连接层1（32→16）</div>
                    <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
                `;
            }
        }

        // 13. 阶段5：全连接层1（32→16）- 详细展示
        function performFullyConnected1() {
            clearAllHighlights();
            
            // 更新当前计算指示器
            document.getElementById('currentNeuron').textContent = fc1Neuron;
            document.getElementById('currentWeight').textContent = fc1WeightIdx;
            
            // 计算当前神经元的当前权重与特征向量的点积
            const weight = fc1Weights[fc1Neuron][fc1WeightIdx];
            const featureVal = finalVector[fc1WeightIdx];
            const product = weight * featureVal;
            
            // 累加当前神经元的分数
            hiddenLayer1[fc1Neuron] += product;
            
            // 高亮当前特征向量元素和权重
            document.getElementById(`fc1-vector-${fc1WeightIdx}`).classList.add('highlight');
            document.getElementById(`fc1-weight-${fc1Neuron}-${fc1WeightIdx}`).classList.add('highlight');
            
            // 高亮当前神经元行
            document.getElementById(`fc1-weight-row-${fc1Neuron}`).classList.add('highlight');
            
            // 更新隐藏层显示
            const hiddenCell = document.getElementById(`hidden1-${fc1Neuron}`);
            hiddenCell.textContent = hiddenLayer1[fc1Neuron].toFixed(4);
            
            // 更新UI
            document.getElementById('calculation').innerHTML = `
                全连接层1：神经元 ${fc1Neuron+1}，权重 ${fc1WeightIdx+1}/32<br>
                计算：${weight.toFixed(4)} × ${featureVal.toFixed(2)} = ${product.toFixed(4)}<br>
                神经元 ${fc1Neuron+1} 当前累计分数：${hiddenLayer1[fc1Neuron].toFixed(4)}<br>
                <br>
                全连接层1通过16个神经元将32维特征向量转换为16维隐藏层。<br>
                每个神经元有32个权重，分别与特征向量的32个元素相乘并累加。
            `;
            document.getElementById('stepIndicator').innerHTML = `
                <div>全连接层1：处理神经元 ${fc1Neuron+1} 的第 ${fc1WeightIdx+1}/32 个权重</div>
                <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
            `;
            
            // 步长更新
            currentStep++;
            updateProgressBar();
            fc1WeightIdx++;
            
            // 当前神经元的所有权重处理完成
            if (fc1WeightIdx >= finalVector.length) {
                // 加上偏置并应用ReLU激活
                hiddenLayer1[fc1Neuron] += fc1Biases[fc1Neuron];
                hiddenLayer1[fc1Neuron] = Math.max(0, hiddenLayer1[fc1Neuron]); // ReLU
                
                // 更新隐藏层显示
                hiddenCell.textContent = hiddenLayer1[fc1Neuron].toFixed(4);
                hiddenCell.classList.add('highlight');
                
                // 重置权重索引，移动到下一个神经元
                fc1WeightIdx = 0;
                fc1Neuron++;
                
                // 所有神经元处理完成，进入全连接层2阶段
                if (fc1Neuron >= HIDDEN_LAYER_SIZE) {
                    currentStage = 5;
                    fc2Neuron = 0;
                    fc2WeightIdx = 0;
                    document.getElementById('stepIndicator').innerHTML = `
                        <div>全连接层1完成！32维特征向量已转换为16维隐藏层。进入全连接层2（16→4）</div>
                        <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
                    `;
                }
            }
        }

        // 14. 阶段6：全连接层2（16→4）
        function performFullyConnected2() {
            clearAllHighlights();
            
            // 计算当前类别的当前权重与隐藏层1的点积
            const weight = fc2Weights[fc2Neuron][fc2WeightIdx];
            const hiddenVal = hiddenLayer1[fc2WeightIdx];
            const product = weight * hiddenVal;
            
            // 累加当前类别的分数
            classScores[fc2Neuron] += product;
            
            // 高亮当前隐藏层1神经元
            document.getElementById(`hidden1-${fc2WeightIdx}`).classList.add('highlight');
            
            // 更新UI
            document.getElementById('calculation').innerHTML = `
                全连接层2：类别 ${fc2Neuron}，权重 ${fc2WeightIdx+1}/16<br>
                计算：${weight.toFixed(4)} × ${hiddenVal.toFixed(4)} = ${product.toFixed(4)}<br>
                类别 ${fc2Neuron} 当前累计分数：${classScores[fc2Neuron].toFixed(4)}
            `;
            document.getElementById('stepIndicator').innerHTML = `
                <div>全连接层2：处理类别 ${fc2Neuron} 的第 ${fc2WeightIdx+1}/16 个权重</div>
                <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
            `;
            
            // 步长更新
            currentStep++;
            updateProgressBar();
            fc2WeightIdx++;
            
            // 当前类别的所有权重处理完成
            if (fc2WeightIdx >= HIDDEN_LAYER_SIZE) {
                // 加上偏置
                classScores[fc2Neuron] += fc2Biases[fc2Neuron];
                
                // 重置权重索引，移动到下一个类别
                fc2WeightIdx = 0;
                fc2Neuron++;
                
                // 所有类别处理完成，进入Softmax阶段
                if (fc2Neuron >= NUM_CLASSES) {
                    currentStage = 6;
                    softmaxStep = 0;
                    document.getElementById('stepIndicator').innerHTML = `
                        <div>全连接层2完成！进入Softmax阶段</div>
                        <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
                    `;
                }
            }
        }

        // 15. 阶段7：Softmax计算
        function performSoftmax() {
            clearAllHighlights();
            
            let calcText = '';
            
            switch(softmaxStep) {
                case 0:
                    // 显示原始分数
                    calcText = `
                        Softmax阶段：将类别分数转换为概率分布<br>
                        原始分数：${classScores.map(s => s.toFixed(4)).join(', ')}
                    `;
                    document.getElementById('calculation').innerHTML = calcText;
                    break;
                    
                case 1:
                    // 计算指数
                    const maxScore = Math.max(...classScores);
                    const expScores = classScores.map(s => Math.exp(s - maxScore)); // 数值稳定性
                    
                    calcText = `
                        Softmax阶段：计算指数（使用数值稳定性技巧）<br>
                        原始分数：${classScores.map(s => s.toFixed(4)).join(', ')}<br>
                        减去最大值：${maxScore.toFixed(4)}<br>
                        指数结果：${expScores.map(e => e.toFixed(4)).join(', ')}
                    `;
                    document.getElementById('calculation').innerHTML = calcText;
                    break;
                    
                case 2:
                    // 计算指数和
                    const maxScore2 = Math.max(...classScores);
                    const expScores2 = classScores.map(s => Math.exp(s - maxScore2));
                    const sumExp = expScores2.reduce((a, b) => a + b, 0);
                    
                    calcText = `
                        Softmax阶段：计算指数和<br>
                        指数结果：${expScores2.map(e => e.toFixed(4)).join(', ')}<br>
                        指数和：${sumExp.toFixed(4)}
                    `;
                    document.getElementById('calculation').innerHTML = calcText;
                    break;
                    
                case 3:
                    // 计算概率
                    const maxScore3 = Math.max(...classScores);
                    const expScores3 = classScores.map(s => Math.exp(s - maxScore3));
                    const sumExp3 = expScores3.reduce((a, b) => a + b, 0);
                    classProbabilities = expScores3.map(e => e / sumExp3);
                    
                    calcText = `
                        Softmax阶段：计算概率<br>
                        指数结果：${expScores3.map(e => e.toFixed(4)).join(', ')}<br>
                        指数和：${sumExp3.toFixed(4)}<br>
                        概率：${classProbabilities.map(p => p.toFixed(4)).join(', ')}
                    `;
                    document.getElementById('calculation').innerHTML = calcText;
                    break;
                    
                case 4:
                    // 更新概率显示
                    for (let i = 0; i < NUM_CLASSES; i++) {
                        const probCell = document.getElementById(`class-prob-${i}`);
                        probCell.querySelector('.class-probability').textContent = classProbabilities[i].toFixed(4);
                        
                        const probBar = document.getElementById(`prob-bar-${i}`);
                        const percentage = (classProbabilities[i] * 100).toFixed(1);
                        probBar.style.width = `${percentage}%`;
                        probBar.textContent = `${percentage}%`;
                    }
                    
                    calcText = `
                        Softmax阶段：概率分布可视化<br>
                        概率：${classProbabilities.map(p => p.toFixed(4)).join(', ')}<br>
                        概率总和：${classProbabilities.reduce((a, b) => a + b, 0).toFixed(4)}
                    `;
                    document.getElementById('calculation').innerHTML = calcText;
                    break;
                    
                case 5:
                    // 找到最大概率的类别
                    const maxProb = Math.max(...classProbabilities);
                    const predictedClass = classProbabilities.indexOf(maxProb);
                    
                    // 高亮预测结果
                    document.getElementById(`class-prob-${predictedClass}`).classList.add('highlight');
                    document.getElementById('predictionResult').textContent = `预测结果: 类别 ${predictedClass} (概率: ${maxProb.toFixed(4)})`;
                    document.getElementById('predictionResult').classList.add('highlight');
                    
                    calcText = `
                        Softmax阶段：最终预测<br>
                        概率分布：${classProbabilities.map(p => p.toFixed(4)).join(', ')}<br>
                        最大概率：${maxProb.toFixed(4)} → 预测类别：${predictedClass}
                    `;
                    document.getElementById('calculation').innerHTML = calcText;
                    
                    // 动画结束
                    currentStage = 7;
                    stopAnimation();
                    document.getElementById('stepIndicator').innerHTML = `
                        <div class="pulse">演示完成！最终预测：类别 ${predictedClass}</div>
                        <div class="progress-container"><div class="progress-bar" id="progressBar" style="width: 100%;"></div></div>
                    `;
                    break;
            }
            
            // 步长更新
            currentStep++;
            updateProgressBar();
            softmaxStep++;
        }

        // 16. 动画控制函数
        function startAnimation() {
            if (isAnimating || currentStage === 7) return;
            isAnimating = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('nextBtn').disabled = true;
            
            animationInterval = setInterval(() => {
                switch(currentStage) {
                    case 0: performConvolution(); break;
                    case 1: performPooling(); break;
                    case 2: performProjection(); break;
                    case 3: performReshape(); break;
                    case 4: performFullyConnected1(); break;
                    case 5: performFullyConnected2(); break;
                    case 6: performSoftmax(); break;
                    case 7: stopAnimation(); break;
                }
            }, 1200); // 1.2秒/步，确保看清过程
        }

        function stopAnimation() {
            clearInterval(animationInterval);
            isAnimating = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('nextBtn').disabled = false;
        }

        function nextStep() {
            if (isAnimating || currentStage === 7) return;
            switch(currentStage) {
                case 0: performConvolution(); break;
                case 1: performPooling(); break;
                case 2: performProjection(); break;
                case 3: performReshape(); break;
                case 4: performFullyConnected1(); break;
                case 5: performFullyConnected2(); break;
                case 6: performSoftmax(); break;
            }
        }

        function resetDemo() {
            stopAnimation();
            // 重置所有计数器和数据
            currentStep = 0;
            currentStage = 0;
            convKernel = 0, convRow = 0, convCol = 0;
            poolKernel = 0, poolRegionIdx = 0;
            projChan = 0, projRow = 0, projCol = 0;
            reshapeIdx = 0;
            fc1Neuron = 0, fc1WeightIdx = 0;
            fc2Neuron = 0, fc2WeightIdx = 0;
            softmaxStep = 0;
            featureMaps = Array(numKernels).fill().map(() => Array(3).fill().map(() => Array(3).fill(0)));
            pooledMaps = Array(numKernels).fill().map(() => Array(poolSize).fill().map(() => Array(poolSize).fill(0)));
            projectedMaps = Array(VISUAL_PROJ_CHANNELS).fill().map(() => Array(poolSize).fill().map(() => Array(poolSize).fill(0)));
            finalVector = Array(VISUAL_PROJ_CHANNELS * poolSize * poolSize).fill(0);
            hiddenLayer1 = Array(HIDDEN_LAYER_SIZE).fill(0);
            classScores = Array(NUM_CLASSES).fill(0);
            classProbabilities = Array(NUM_CLASSES).fill(0);
            
            // 重置UI
            initializeGrids();
            document.getElementById('stepIndicator').innerHTML = `
                <div>准备演示完整CNN特征提取与分类流程...</div>
                <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
            `;
            document.getElementById('calculation').innerHTML = '点击"开始演示"查看详细计算过程...';
            document.getElementById('predictionResult').textContent = '等待分类...';
            document.getElementById('predictionResult').classList.remove('highlight');
        }

        // 页面加载初始化
        document.addEventListener('DOMContentLoaded', () => {
            initializeGrids();
            document.getElementById('startBtn').addEventListener('click', startAnimation);
            document.getElementById('resetBtn').addEventListener('click', resetDemo);
            document.getElementById('nextBtn').addEventListener('click', nextStep);
        });
    </script>
</body>
</html>